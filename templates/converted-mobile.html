<!DOCTYPE html>
<!-- MOBILE TEMPLATE - converted-mobile.html -->
<html>
  <head>
    <title>PDF - {{ filename }}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100vh;
        overflow-x: auto;
        overflow-y: auto;
        background: #f3f4f6;
        -webkit-overflow-scrolling: touch;
        margin: 0;
        padding: 0;
      }

      .pdf-container {
        width: 100%;
        height: 100vh;
        min-height: 100vh;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        overflow: auto;
        position: relative;
        background: #f3f4f6;
      }

      .pdf-page {
        width: 100%;
        max-width: 100%;
        background: white;
        margin: 0 auto;
        display: block;
        position: relative;
        page-break-after: always;
        flex-shrink: 0;
      }

      .pdf-page:not(.hidden) {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      .pdf-page.hidden {
        display: none !important;
      }

      .text-line {
        position: relative;
      }

      .text-span {
        position: absolute;
      }

      .editable-image {
        position: absolute;
      }

      /* Ensure select dropdowns appear above everything */
      select {
        position: relative;
        z-index: 99999 !important;
      }

      /* Ensure select dropdown options appear above everything */
      select option {
        z-index: 99999 !important;
      }

      /* Ensure text formatting toolbar and its children have proper z-index */
      .text-formatting-toolbar {
        z-index: 99998 !important;
        position: relative;
        overflow: visible !important;
      }

      /* Delete button styles - now in toolbar, but keep for signatures */
      .element-delete-btn {
        position: absolute;
        top: -12px;
        right: -12px;
        width: 32px;
        height: 32px;
        background: #dc3545;
        color: white;
        border: none;
        border-radius: 50%;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 200;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        opacity: 0;
        transition: opacity 0.2s ease, transform 0.2s ease, background 0.2s ease;
        pointer-events: none;
        touch-action: manipulation;
      }

      .element-delete-btn:hover,
      .element-delete-btn:active {
        background: #c82333;
        transform: scale(1.1);
      }

      /* Show delete button when signature is selected */
      .signature-container.selected .element-delete-btn {
        opacity: 1;
        pointer-events: auto;
      }

      /* Show delete button when image is selected */
      .image-container.selected .element-delete-btn {
        opacity: 1;
        pointer-events: auto;
      }

      .text-formatting-toolbar select,
      .text-formatting-toolbar input[type="color"] {
        z-index: 99999 !important;
        position: relative;
      }

      /* Ensure text element container doesn't block dropdowns */
      .text-element-container {
        z-index: 100 !important;
        overflow: visible !important;
      }
    </style>
  </head>
  <body>
    <div class="pdf-container">
      {% for page in pages %} {{ page.html | safe }} {% endfor %}
    </div>
    <script>
      // MOBILE TEMPLATE - Zoom and page display
      console.log("ðŸ“± [MOBILE TEMPLATE] converted-mobile.html loaded");

      let currentPage = 1;
      const totalPages = parseInt("{{ pages|length }}");
      let currentZoom = 1.0; // Zoom multiplier (1.0 = 100%)
      let baseScales = {}; // Store base scale for each page

      // GLOBAL flags to disable page touch handlers when select/input is open
      // These must be defined at top level so handlePageTouchStart can access them
      let isSelectOpen = false;
      let isSizeSelectOpen = false;
      let isColorInputOpen = false;

      // Apply zoom to visible page
      function applyZoom(zoom) {
        currentZoom = zoom;
        const pages = document.querySelectorAll(".pdf-page");
        const viewportWidth = window.innerWidth;

        pages.forEach((page, index) => {
          if (!page.classList.contains("hidden")) {
            const pageNum = index + 1;
            const baseScale = baseScales[pageNum] || 1;
            const dataWidth =
              parseFloat(page.getAttribute("data-width")) || 595;
            const dataHeight =
              parseFloat(page.getAttribute("data-height")) || 842;

            // Base dimensions (at 100% zoom)
            const baseWidth = viewportWidth;
            const baseHeight = dataHeight * baseScale;

            // Keep base dimensions, use transform to scale
            page.style.width = baseWidth + "px";
            page.style.height = baseHeight + "px";

            if (zoom < 1.0) {
              // Zoom out: scale down and center with white background
              page.style.transform = `scale(${zoom})`;
              page.style.transformOrigin = "center center";
              page.style.margin = "auto";
            } else {
              // Zoom in: scale up, allow scrolling from top-left
              page.style.transform = `scale(${zoom})`;
              page.style.transformOrigin = "top left";
              page.style.margin = "0";
            }
          }
        });
      }

      function showPage(pageNumber) {
        const pages = document.querySelectorAll(".pdf-page");
        const totalPagesCount = pages.length;
        let visibleCount = 0;

        pages.forEach((page, index) => {
          if (index + 1 === pageNumber) {
            page.classList.remove("hidden");
            page.style.display = "block";
            page.style.visibility = "visible";
            page.style.opacity = "1";
            visibleCount++;
          } else {
            page.classList.add("hidden");
            page.style.display = "none";
            page.style.visibility = "hidden";
            page.style.opacity = "0";
          }
        });

        currentPage = pageNumber;
        // Reapply zoom when page changes
        applyZoom(currentZoom);

        console.log(
          `ðŸ“„ [Mobile PDF] Pages: ${totalPagesCount} total, ${visibleCount} visible (showing page ${pageNumber})`
        );
      }

      // Custom confirmation function that uses postMessage instead of browser confirm()
      let confirmationCallbacks = {};
      let confirmationIdCounter = 0;

      function showConfirmation(message) {
        return new Promise((resolve, reject) => {
          const id = "confirm_" + Date.now() + "_" + confirmationIdCounter++;

          // Set up listener for response
          let timeoutId;
          const handleResponse = (event) => {
            console.log(
              "ðŸ—‘ï¸ [Mobile] Message received in confirmation handler:",
              event.data
            );
            if (
              event.data &&
              event.data.type === "CONFIRMATION_RESPONSE" &&
              event.data.id === id
            ) {
              console.log("ðŸ—‘ï¸ [Mobile] Confirmation response matches ID:", id);
              if (timeoutId) clearTimeout(timeoutId);
              window.removeEventListener("message", handleResponse);
              delete confirmationCallbacks[id];
              console.log(
                "ðŸ—‘ï¸ [Mobile] Confirmation response received:",
                event.data.confirmed
              );
              resolve(event.data.confirmed);
            }
          };

          // Set timeout to reject if no response (30 seconds)
          timeoutId = setTimeout(() => {
            window.removeEventListener("message", handleResponse);
            delete confirmationCallbacks[id];
            console.error(
              "ðŸ—‘ï¸ [Mobile] Confirmation timeout - no response from parent"
            );
            reject(new Error("Confirmation timeout"));
          }, 30000);

          window.addEventListener("message", handleResponse);
          confirmationCallbacks[id] = { resolve, timeoutId, handleResponse };

          // Send confirmation request to parent
          console.log("ðŸ—‘ï¸ [Mobile] Sending confirmation request to parent:", {
            id,
            message,
          });
          window.parent.postMessage(
            {
              type: "SHOW_CONFIRMATION",
              id: id,
              message: message,
            },
            "*"
          );
        });
      }

      document.addEventListener("DOMContentLoaded", function () {
        const pages = document.querySelectorAll(".pdf-page");
        const totalPagesCount = pages.length;

        console.log(`ðŸ“‘ [Mobile PDF] Total pages found: ${totalPagesCount}`);

        // Initially show only first page
        showPage(1);

        pages.forEach((page, index) => {
          const pageNum = index + 1;
          const dataWidth = parseFloat(page.getAttribute("data-width")) || 595;
          const dataHeight =
            parseFloat(page.getAttribute("data-height")) || 842;

          // Calculate base scale to fit width (100% of viewport)
          const viewportWidth = window.innerWidth;
          const baseScale = viewportWidth / dataWidth;
          baseScales[pageNum] = baseScale;

          // Set initial dimensions (will be adjusted by zoom)
          page.style.width = viewportWidth + "px";
          page.style.height = dataHeight * baseScale + "px";

          // Scale all absolutely positioned content inside the page
          const textSpans = page.querySelectorAll(".text-span, .editable-text");
          const images = page.querySelectorAll(".editable-image");

          textSpans.forEach((span) => {
            const left = parseFloat(span.style.left) || 0;
            const top = parseFloat(span.style.top) || 0;
            const fontSize = parseFloat(span.style.fontSize) || 12;

            span.style.left = left * baseScale + "px";
            span.style.top = top * baseScale + "px";
            span.style.fontSize = fontSize * baseScale + "px";
          });

          images.forEach((img) => {
            const left = parseFloat(img.style.left) || 0;
            const top = parseFloat(img.style.top) || 0;
            const width = parseFloat(img.style.width) || 0;
            const height = parseFloat(img.style.height) || 0;

            img.style.left = left * baseScale + "px";
            img.style.top = top * baseScale + "px";
            img.style.width = width * baseScale + "px";
            img.style.height = height * baseScale + "px";
          });
        });

        // Apply initial zoom
        applyZoom(1.0);

        // Listen for messages from parent
        window.addEventListener("message", function (event) {
          if (event.data && event.data.type === "CHANGE_PAGE") {
            const pageNumber = event.data.pageNumber;
            if (pageNumber >= 1 && pageNumber <= totalPages) {
              showPage(pageNumber);
            }
          } else if (event.data && event.data.type === "MOBILE_ZOOM") {
            const zoom = event.data.zoom;
            if (typeof zoom === "number" && zoom >= 0.25 && zoom <= 3.0) {
              applyZoom(zoom);
            }
          } else if (event.data && event.data.type === "SET_EDIT_MODE") {
            // Handle edit mode - for mobile, enable text editing on existing text elements
            console.log("ðŸ“± [Mobile] Setting edit mode to:", event.data.mode);
            const mode = event.data.mode;

            // Enable contentEditable on text elements when edit-text mode is active
            if (mode === "edit-text") {
              document
                .querySelectorAll(".editable-text, .text-span")
                .forEach((element) => {
                  element.contentEditable = true;
                  element.style.cursor = "text";
                  element.addEventListener("click", function (e) {
                    e.stopPropagation();
                  });
                });
            } else if (mode === "text") {
              // Add text mode - create text element on tap
              console.log("ðŸ“ [Mobile] Add text mode activated");
              const page = document.querySelector(".pdf-page:not(.hidden)");
              console.log("ðŸ“ [Mobile] Page found for text creation:", !!page);
              if (page) {
                // Remove previous handlers
                console.log(
                  "ðŸ“ [Mobile] Removing previous text creation handlers"
                );
                page.removeEventListener("click", createTextOnClick);
                page.removeEventListener("touchend", createTextOnTouch);

                // Add touchstart handler to allow form controls to work natively
                function handlePageTouchStart(e) {
                  // CRITICAL: If ANY select/input is open, completely ignore ALL touches
                  // This allows native picker options to be selected without interference
                  if (isSelectOpen || isSizeSelectOpen || isColorInputOpen) {
                    console.log(
                      "ðŸ“ [Mobile] Page touchstart - select/input is open, ignoring touch completely"
                    );
                    return; // Don't interfere at all when picker is open
                  }

                  // If touching a form control, allow native behavior completely
                  if (
                    e.target.tagName === "SELECT" ||
                    e.target.tagName === "INPUT" ||
                    e.target.closest("select") ||
                    e.target.closest("input") ||
                    e.target.closest(".text-formatting-toolbar") ||
                    e.target.closest(".text-element-container")
                  ) {
                    console.log(
                      "ðŸ“ [Mobile] Page touchstart on form control - allowing native behavior"
                    );
                    // Stop propagation to prevent other handlers from interfering
                    e.stopPropagation();
                    // DON'T prevent default - let native dropdown work
                    return; // Just return early, don't interfere
                  }
                  // For other touches, don't interfere (text creation happens on touchend)
                }

                // Add handlers for both click and touch (once only - auto-remove after first use)
                // Note: Not using passive: true because we need stopImmediatePropagation()
                page.addEventListener("touchstart", handlePageTouchStart);
                page.addEventListener("click", createTextOnClick, {
                  once: true,
                });
                page.addEventListener("touchend", createTextOnTouch, {
                  once: true,
                });
                console.log(
                  "ðŸ“ [Mobile] Click and touch handlers added for text creation (once only)"
                );
                console.log("ðŸ“ [Mobile] Page element:", page);
                console.log("ðŸ“ [Mobile] Page classes:", page.className);
                console.log(
                  "ðŸ“ [Mobile] Page display:",
                  window.getComputedStyle(page).display
                );
              } else {
                console.error(
                  "âŒ [Mobile] No visible page found for text creation"
                );
              }
            } else {
              // Disable editing for other modes
              console.log(
                "ðŸ“ [Mobile] Disabling text creation mode, mode:",
                mode
              );
              document
                .querySelectorAll(".editable-text, .text-span")
                .forEach((element) => {
                  element.contentEditable = false;
                  element.style.cursor = "default";
                });
              // Remove text creation handlers
              const page = document.querySelector(".pdf-page:not(.hidden)");
              if (page) {
                console.log("ðŸ“ [Mobile] Removing text creation handlers");
                page.removeEventListener("click", createTextOnClick);
                page.removeEventListener("touchend", createTextOnTouch);
              }
            }

            // Send confirmation back to parent
            window.parent.postMessage(
              {
                type: "EDIT_MODE_SET",
                mode: mode,
              },
              "*"
            );
          } else if (
            event.data &&
            event.data.type === "GENERATE_PDF_FOR_PREVIEW"
          ) {
            // Generate PDF for preview using html2canvas and jsPDF
            console.log("ðŸ“± [Mobile] Generating PDF for preview");
            generatePDFForPreview();
          } else if (event.data && event.data.type === "INSERT_SIGNATURE") {
            // Insert signature into the current page
            console.log("âœï¸ [Mobile] Inserting signature");
            insertSignature(
              event.data.signatureData,
              event.data.page || currentPage
            );
          } else if (event.data && event.data.type === "INSERT_IMAGE") {
            // Insert image into the current page
            console.log("ðŸ–¼ï¸ [Mobile] Inserting image");
            insertImage(
              event.data.imageData,
              event.data.fileName || "image",
              event.data.page || currentPage
            );
          }
        });

        // Create text element on touch
        function createTextOnTouch(e) {
          console.log("ðŸ“ [Mobile] createTextOnTouch called");
          console.log("ðŸ“ [Mobile] Touch event:", e);

          // Don't create text if clicking on form controls or toolbar
          if (
            e.target.tagName === "SELECT" ||
            e.target.tagName === "INPUT" ||
            e.target.closest("select") ||
            e.target.closest("input") ||
            e.target.closest(".text-formatting-toolbar") ||
            e.target.closest(".text-element-container")
          ) {
            console.log(
              "ðŸ“ [Mobile] Touch on form control or toolbar, ignoring"
            );
            return; // Allow native behavior
          }

          e.preventDefault();
          const page = e.currentTarget;
          console.log("ðŸ“ [Mobile] Page element from touch:", page);
          const pageRect = page.getBoundingClientRect();
          console.log("ðŸ“ [Mobile] Page rect:", pageRect);
          const touch = e.changedTouches[0];
          console.log(
            "ðŸ“ [Mobile] Touch coordinates:",
            touch.clientX,
            touch.clientY
          );
          const x = touch.clientX - pageRect.left;
          const y = touch.clientY - pageRect.top;
          console.log("ðŸ“ [Mobile] Calculated position:", x, y);
          createTextElement(page, x, y);
        }

        // Create text element on click
        function createTextOnClick(e) {
          console.log("ðŸ“ [Mobile] createTextOnClick called");
          console.log("ðŸ“ [Mobile] Click event:", e);

          // Don't create text if clicking on form controls or toolbar
          if (
            e.target.tagName === "SELECT" ||
            e.target.tagName === "INPUT" ||
            e.target.closest("select") ||
            e.target.closest("input") ||
            e.target.closest(".text-formatting-toolbar") ||
            e.target.closest(".text-element-container")
          ) {
            console.log(
              "ðŸ“ [Mobile] Click on form control or toolbar, ignoring"
            );
            return; // Allow native behavior
          }

          const page = e.currentTarget;
          console.log("ðŸ“ [Mobile] Page element from click:", page);
          const pageRect = page.getBoundingClientRect();
          console.log("ðŸ“ [Mobile] Page rect:", pageRect);
          console.log("ðŸ“ [Mobile] Click coordinates:", e.clientX, e.clientY);
          const x = e.clientX - pageRect.left;
          const y = e.clientY - pageRect.top;
          console.log("ðŸ“ [Mobile] Calculated position:", x, y);
          createTextElement(page, x, y);
        }

        // Create text element at position
        function createTextElement(page, x, y) {
          console.log("ðŸ“ [Mobile] createTextElement called");
          console.log("ðŸ“ [Mobile] Page:", page);
          console.log("ðŸ“ [Mobile] Position:", x, y);

          // Remove handlers immediately to prevent multiple creations
          console.log("ðŸ“ [Mobile] Removing text creation handlers");
          page.removeEventListener("click", createTextOnClick);
          page.removeEventListener("touchend", createTextOnTouch);

          // Create text container
          console.log("ðŸ“ [Mobile] Creating text container");
          const textContainer = document.createElement("div");
          textContainer.className = "text-element-container";
          textContainer.style.position = "absolute";
          textContainer.style.left = x + "px";
          textContainer.style.top = y + "px";
          textContainer.style.minWidth = "100px";
          textContainer.style.minHeight = "30px";
          textContainer.style.zIndex = "100";
          textContainer.style.overflow = "visible"; // Ensure dropdowns aren't clipped
          textContainer.style.border = "2px dashed rgba(255, 255, 255, 0.2)";
          textContainer.style.padding = "8px";
          textContainer.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
          textContainer.style.borderRadius = "12px";
          textContainer.style.transition = "none"; // NO TRANSITION - instant updates for dragging
          console.log(
            "ðŸ“ [Mobile] Text container created with position:",
            x,
            y
          );

          // Create simple button-based formatting toolbar
          console.log("ðŸ“ [Mobile] Creating formatting toolbar");
          const toolbar = document.createElement("div");
          toolbar.className = "text-formatting-toolbar";
          toolbar.style.position = "absolute";
          toolbar.style.top = "-70px";
          toolbar.style.left = "50%";
          toolbar.style.transform = "translateX(-50%)";
          toolbar.style.zIndex = "99998";
          toolbar.style.display = "none";
          toolbar.style.gap = "8px";
          toolbar.style.padding = "10px 12px";
          toolbar.style.backgroundColor = "rgba(255, 255, 255, 0.98)";
          toolbar.style.backdropFilter = "blur(20px)";
          toolbar.style.borderRadius = "12px";
          toolbar.style.alignItems = "center";
          toolbar.style.boxShadow =
            "0 4px 20px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.1)";
          toolbar.style.border = "1px solid rgba(0, 0, 0, 0.1)";
          toolbar.style.flexWrap = "nowrap";
          toolbar.style.maxWidth = "90vw";
          toolbar.style.flexDirection = "row";
          console.log("ðŸ“ [Mobile] Toolbar created");

          // Current formatting values
          let currentFont = "Arial";
          let currentSize = "14";
          let currentColor = "#000000";
          let isBold = false;

          // Font button
          const fontButton = document.createElement("button");
          fontButton.textContent = "Font";
          fontButton.style.padding = "8px 14px";
          fontButton.style.fontSize = "13px";
          fontButton.style.borderRadius = "8px";
          fontButton.style.border = "1px solid rgba(209, 213, 219, 0.8)";
          fontButton.style.backgroundColor = "rgba(249, 250, 251, 0.9)";
          fontButton.style.color = "#374151";
          fontButton.style.cursor = "pointer";
          fontButton.style.fontWeight = "500";
          fontButton.style.minWidth = "70px";
          fontButton.style.transition = "all 0.2s ease";
          fontButton.style.pointerEvents = "auto";
          fontButton.style.zIndex = "99999";
          fontButton.style.position = "relative";
          fontButton.style.flexShrink = "0";

          // Size button
          const sizeButton = document.createElement("button");
          sizeButton.textContent = "14px";
          sizeButton.style.padding = "8px 14px";
          sizeButton.style.fontSize = "13px";
          sizeButton.style.borderRadius = "8px";
          sizeButton.style.border = "1px solid rgba(209, 213, 219, 0.8)";
          sizeButton.style.backgroundColor = "rgba(249, 250, 251, 0.9)";
          sizeButton.style.color = "#374151";
          sizeButton.style.cursor = "pointer";
          sizeButton.style.fontWeight = "500";
          sizeButton.style.minWidth = "60px";
          sizeButton.style.transition = "all 0.2s ease";
          sizeButton.style.pointerEvents = "auto";
          sizeButton.style.zIndex = "99999";
          sizeButton.style.position = "relative";
          sizeButton.style.flexShrink = "0";

          // Color button
          const colorButton = document.createElement("button");
          colorButton.style.width = "40px";
          colorButton.style.height = "40px";
          colorButton.style.borderRadius = "8px";
          colorButton.style.border = "2px solid rgba(209, 213, 219, 0.8)";
          colorButton.style.backgroundColor = "#000000";
          colorButton.style.cursor = "pointer";
          colorButton.style.transition = "all 0.2s ease";
          colorButton.style.pointerEvents = "auto";
          colorButton.style.zIndex = "99999";
          colorButton.style.position = "relative";
          colorButton.style.padding = "0";
          colorButton.style.minWidth = "40px";
          colorButton.style.flexShrink = "0";

          // Bold button
          const boldButton = document.createElement("button");
          boldButton.textContent = "B";
          boldButton.style.padding = "8px 14px";
          boldButton.style.fontSize = "16px";
          boldButton.style.fontWeight = "bold";
          boldButton.style.borderRadius = "8px";
          boldButton.style.border = "1px solid rgba(209, 213, 219, 0.8)";
          boldButton.style.backgroundColor = "rgba(249, 250, 251, 0.9)";
          boldButton.style.color = "#374151";
          boldButton.style.cursor = "pointer";
          boldButton.style.minWidth = "40px";
          boldButton.style.transition = "all 0.2s ease";
          boldButton.style.pointerEvents = "auto";
          boldButton.style.zIndex = "99999";
          boldButton.style.position = "relative";
          boldButton.style.flexShrink = "0";

          // Done/Close button to exit text editing
          const doneButton = document.createElement("button");
          doneButton.textContent = "Done";
          doneButton.style.padding = "8px 14px";
          doneButton.style.fontSize = "13px";
          doneButton.style.borderRadius = "8px";
          doneButton.style.border = "1px solid rgba(34, 197, 94, 0.8)";
          doneButton.style.backgroundColor = "rgba(34, 197, 94, 0.1)";
          doneButton.style.color = "#16a34a";
          doneButton.style.cursor = "pointer";
          doneButton.style.fontWeight = "600";
          doneButton.style.minWidth = "60px";
          doneButton.style.transition = "all 0.2s ease";
          doneButton.style.pointerEvents = "auto";
          doneButton.style.zIndex = "99999";
          doneButton.style.position = "relative";
          doneButton.style.flexShrink = "0";

          // Delete button - add to toolbar
          const deleteBtn = document.createElement("button");
          deleteBtn.innerHTML = "ðŸ—‘ï¸";
          deleteBtn.title = "Delete text";
          deleteBtn.style.padding = "8px 14px";
          deleteBtn.style.fontSize = "16px";
          deleteBtn.style.borderRadius = "8px";
          deleteBtn.style.border = "1px solid rgba(220, 53, 69, 0.8)";
          deleteBtn.style.backgroundColor = "rgba(220, 53, 69, 0.1)";
          deleteBtn.style.color = "#dc3545";
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.fontWeight = "600";
          deleteBtn.style.minWidth = "40px";
          deleteBtn.style.transition = "all 0.2s ease";
          deleteBtn.style.pointerEvents = "auto";
          deleteBtn.style.zIndex = "99999";
          deleteBtn.style.position = "relative";
          deleteBtn.style.flexShrink = "0";
          deleteBtn.style.display = "flex";
          deleteBtn.style.alignItems = "center";
          deleteBtn.style.justifyContent = "center";

          // Delete button event handler - prevent multiple clicks
          let isDeleting = false;
          let deleteTimeoutId = null;
          deleteBtn.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();

            // Prevent multiple simultaneous delete attempts
            if (isDeleting) {
              console.log(
                "ðŸ—‘ï¸ [Mobile] Delete already in progress, ignoring click"
              );
              return;
            }

            isDeleting = true;
            console.log("ðŸ—‘ï¸ [Mobile] Delete button clicked for text element");

            // Set timeout to reset flag if confirmation doesn't respond (15 seconds)
            if (deleteTimeoutId) clearTimeout(deleteTimeoutId);
            deleteTimeoutId = setTimeout(() => {
              console.warn(
                "ðŸ—‘ï¸ [Mobile] Delete confirmation timeout - resetting flag"
              );
              isDeleting = false;
              deleteTimeoutId = null;
            }, 15000);

            try {
              const confirmed = await showConfirmation(
                "Are you sure you want to delete this text element?"
              );
              if (deleteTimeoutId) {
                clearTimeout(deleteTimeoutId);
                deleteTimeoutId = null;
              }
              if (confirmed) {
                textContainer.remove();
                console.log("ðŸ—‘ï¸ [Mobile] Text element deleted");
              } else {
                console.log("ðŸ—‘ï¸ [Mobile] Delete cancelled by user");
              }
            } catch (error) {
              console.error("ðŸ—‘ï¸ [Mobile] Error during delete:", error);
            } finally {
              if (deleteTimeoutId) {
                clearTimeout(deleteTimeoutId);
                deleteTimeoutId = null;
              }
              isDeleting = false;
            }
          });

          // Add buttons to toolbar
          toolbar.appendChild(fontButton);
          toolbar.appendChild(sizeButton);
          toolbar.appendChild(colorButton);
          toolbar.appendChild(boldButton);
          toolbar.appendChild(deleteBtn);
          toolbar.appendChild(doneButton);

          // Create editable text element
          console.log("ðŸ“ [Mobile] Creating editable text element");
          const textElement = document.createElement("div");
          textElement.className = "new-text-element";
          textElement.contentEditable = true;
          textElement.style.outline = "none";
          textElement.style.minWidth = "100px";
          textElement.style.minHeight = "20px";
          textElement.textContent = "New Text";
          textElement.style.cursor = "text";
          textElement.style.fontSize = "14px";
          textElement.style.fontFamily = "Arial";
          textElement.style.color = "#000000";
          console.log("ðŸ“ [Mobile] Text element created");

          // Function to show font selection modal
          const showFontModal = () => {
            const modal = document.createElement("div");
            modal.style.position = "fixed";
            modal.style.top = "0";
            modal.style.left = "0";
            modal.style.width = "100%";
            modal.style.height = "100%";
            modal.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
            modal.style.zIndex = "100000";
            modal.style.display = "flex";
            modal.style.alignItems = "center";
            modal.style.justifyContent = "center";

            const content = document.createElement("div");
            content.style.backgroundColor = "white";
            content.style.borderRadius = "16px";
            content.style.padding = "24px";
            content.style.maxWidth = "90%";
            content.style.width = "300px";
            content.style.maxHeight = "80vh";
            content.style.overflowY = "auto";

            const title = document.createElement("h3");
            title.textContent = "Select Font";
            title.style.margin = "0 0 16px 0";
            title.style.fontSize = "18px";
            title.style.fontWeight = "600";
            content.appendChild(title);

            const fonts = [
              "Arial",
              "Times New Roman",
              "Courier New",
              "Georgia",
              "Verdana",
              "Helvetica",
            ];
            fonts.forEach((font) => {
              const option = document.createElement("button");
              option.textContent = font;
              option.style.width = "100%";
              option.style.padding = "12px";
              option.style.marginBottom = "8px";
              option.style.borderRadius = "8px";
              option.style.border = "1px solid #e5e7eb";
              option.style.backgroundColor =
                currentFont === font ? "#3b82f6" : "white";
              option.style.color = currentFont === font ? "white" : "#374151";
              option.style.cursor = "pointer";
              option.style.fontFamily = font;
              option.style.fontSize = "14px";
              option.style.textAlign = "left";
              option.onclick = () => {
                currentFont = font;
                textElement.style.fontFamily = font;
                fontButton.textContent =
                  font.length > 8 ? font.substring(0, 8) + "..." : font;
                document.body.removeChild(modal);
              };
              content.appendChild(option);
            });

            modal.onclick = (e) => {
              if (e.target === modal) {
                document.body.removeChild(modal);
              }
            };

            modal.appendChild(content);
            document.body.appendChild(modal);
          };

          // Function to show size selection modal
          const showSizeModal = () => {
            const modal = document.createElement("div");
            modal.style.position = "fixed";
            modal.style.top = "0";
            modal.style.left = "0";
            modal.style.width = "100%";
            modal.style.height = "100%";
            modal.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
            modal.style.zIndex = "100000";
            modal.style.display = "flex";
            modal.style.alignItems = "center";
            modal.style.justifyContent = "center";

            const content = document.createElement("div");
            content.style.backgroundColor = "white";
            content.style.borderRadius = "16px";
            content.style.padding = "24px";
            content.style.maxWidth = "90%";
            content.style.width = "250px";
            content.style.maxHeight = "80vh";
            content.style.overflowY = "auto";

            const title = document.createElement("h3");
            title.textContent = "Select Size";
            title.style.margin = "0 0 16px 0";
            title.style.fontSize = "18px";
            title.style.fontWeight = "600";
            content.appendChild(title);

            const sizes = [
              "10",
              "12",
              "14",
              "16",
              "18",
              "20",
              "24",
              "28",
              "32",
            ];
            sizes.forEach((size) => {
              const option = document.createElement("button");
              option.textContent = size + "px";
              option.style.width = "100%";
              option.style.padding = "12px";
              option.style.marginBottom = "8px";
              option.style.borderRadius = "8px";
              option.style.border = "1px solid #e5e7eb";
              option.style.backgroundColor =
                currentSize === size ? "#3b82f6" : "white";
              option.style.color = currentSize === size ? "white" : "#374151";
              option.style.cursor = "pointer";
              option.style.fontSize = size + "px";
              option.style.textAlign = "left";
              option.onclick = () => {
                currentSize = size;
                textElement.style.fontSize = size + "px";
                sizeButton.textContent = size + "px";
                document.body.removeChild(modal);
              };
              content.appendChild(option);
            });

            modal.onclick = (e) => {
              if (e.target === modal) {
                document.body.removeChild(modal);
              }
            };

            modal.appendChild(content);
            document.body.appendChild(modal);
          };

          // Function to show color picker modal
          const showColorModal = () => {
            const modal = document.createElement("div");
            modal.style.position = "fixed";
            modal.style.top = "0";
            modal.style.left = "0";
            modal.style.width = "100%";
            modal.style.height = "100%";
            modal.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
            modal.style.zIndex = "100000";
            modal.style.display = "flex";
            modal.style.alignItems = "center";
            modal.style.justifyContent = "center";

            const content = document.createElement("div");
            content.style.backgroundColor = "white";
            content.style.borderRadius = "16px";
            content.style.padding = "24px";
            content.style.maxWidth = "90%";
            content.style.width = "300px";

            const title = document.createElement("h3");
            title.textContent = "Select Color";
            title.style.margin = "0 0 16px 0";
            title.style.fontSize = "18px";
            title.style.fontWeight = "600";
            content.appendChild(title);

            const colorInput = document.createElement("input");
            colorInput.type = "color";
            colorInput.value = currentColor;
            colorInput.style.width = "100%";
            colorInput.style.height = "60px";
            colorInput.style.border = "2px solid #e5e7eb";
            colorInput.style.borderRadius = "8px";
            colorInput.style.cursor = "pointer";
            colorInput.onchange = (e) => {
              currentColor = e.target.value;
              textElement.style.color = currentColor;
              colorButton.style.backgroundColor = currentColor;
              document.body.removeChild(modal);
            };
            content.appendChild(colorInput);

            const presetColors = [
              "#000000",
              "#FFFFFF",
              "#FF0000",
              "#00FF00",
              "#0000FF",
              "#FFFF00",
              "#FF00FF",
              "#00FFFF",
              "#808080",
              "#FFA500",
            ];
            const presetContainer = document.createElement("div");
            presetContainer.style.display = "grid";
            presetContainer.style.gridTemplateColumns = "repeat(5, 1fr)";
            presetContainer.style.gap = "8px";
            presetContainer.style.marginTop = "16px";
            presetColors.forEach((color) => {
              const preset = document.createElement("button");
              preset.style.width = "40px";
              preset.style.height = "40px";
              preset.style.borderRadius = "8px";
              preset.style.border = "2px solid #e5e7eb";
              preset.style.backgroundColor = color;
              preset.style.cursor = "pointer";
              preset.onclick = () => {
                currentColor = color;
                textElement.style.color = currentColor;
                colorButton.style.backgroundColor = currentColor;
                document.body.removeChild(modal);
              };
              presetContainer.appendChild(preset);
            });
            content.appendChild(presetContainer);

            modal.onclick = (e) => {
              if (e.target === modal) {
                document.body.removeChild(modal);
              }
            };

            modal.appendChild(content);
            document.body.appendChild(modal);
          };

          // Add button event listeners
          fontButton.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            showFontModal();
          });

          sizeButton.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            showSizeModal();
          });

          colorButton.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            showColorModal();
          });

          // Bold button - toggle bold
          boldButton.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            isBold = !isBold;
            if (isBold) {
              textElement.style.fontWeight = "bold";
              boldButton.style.backgroundColor = "#3b82f6";
              boldButton.style.color = "white";
            } else {
              textElement.style.fontWeight = "normal";
              boldButton.style.backgroundColor = "rgba(249, 250, 251, 0.9)";
              boldButton.style.color = "#374151";
            }
            console.log("ðŸ“ [Mobile] Bold toggled:", isBold);
          });

          // Done button - exit text editing mode
          doneButton.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            // Hide toolbar and make text non-editable but draggable
            toolbar.style.display = "none";
            textElement.contentEditable = false;
            textElement.blur();
            textContainer.style.border = "2px dashed rgba(255, 255, 255, 0.2)";
            textContainer.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
            textContainer.style.boxShadow = "none";
            // Switch back to select mode
            window.parent.postMessage(
              {
                type: "SET_EDIT_MODE",
                mode: "select",
              },
              "*"
            );
            console.log(
              "ðŸ“ [Mobile] Done button clicked - hiding toolbar, text is now draggable"
            );
          });

          // Prevent blur when clicking on toolbar
          toolbar.addEventListener("mousedown", (e) => {
            e.stopPropagation();
          });

          toolbar.addEventListener("touchstart", (e) => {
            e.stopPropagation();
          });

          // Show/hide toolbar on text element focus/blur
          textElement.addEventListener("focus", () => {
            console.log("ðŸ“ [Mobile] Text element focused");
            toolbar.style.display = "flex";
            textContainer.style.border = "2px solid rgba(255, 255, 255, 0.4)";
            textContainer.style.backgroundColor = "rgba(255, 255, 255, 0.1)";
            textContainer.style.boxShadow =
              "0 0 0 4px rgba(255, 255, 255, 0.1)";
            console.log("ðŸ“ [Mobile] Toolbar shown");
          });

          textElement.addEventListener("blur", (e) => {
            const relatedTarget = e.relatedTarget;
            if (relatedTarget && toolbar.contains(relatedTarget)) {
              return;
            }

            setTimeout(() => {
              const activeElement = document.activeElement;
              if (
                activeElement !== textElement &&
                !toolbar.contains(activeElement) &&
                !document.querySelector('[style*="z-index: 100000"]') // Don't hide if modal is open
              ) {
                console.log("ðŸ“ [Mobile] Text element blur - hiding toolbar");
                toolbar.style.display = "none";
                textContainer.style.border =
                  "2px dashed rgba(255, 255, 255, 0.2)";
                textContainer.style.backgroundColor =
                  "rgba(255, 255, 255, 0.05)";
                textContainer.style.boxShadow = "none";
              }
            }, 200);
          });

          textContainer.appendChild(toolbar);
          textContainer.appendChild(textElement);
          console.log("ðŸ“ [Mobile] Appending text container to page");
          page.appendChild(textContainer);
          console.log("ðŸ“ [Mobile] Text container appended to page");
          console.log("ðŸ“ [Mobile] Page children count:", page.children.length);

          // Make text container draggable
          let isDragging = false;
          let dragStartTime = 0;
          let dragStartX = 0;
          let dragStartY = 0;
          let startX, startY;
          let cachedPageRect = null;

          // Click handler to show toolbar when text is clicked (but not when dragging)
          textElement.addEventListener("click", (e) => {
            // Only show toolbar if it's hidden and not dragging
            if (toolbar.style.display === "none" && !isDragging) {
              e.stopPropagation();
              toolbar.style.display = "flex";
              textElement.contentEditable = true;
              textElement.focus();
              textContainer.style.border = "2px solid rgba(255, 255, 255, 0.4)";
              textContainer.style.backgroundColor = "rgba(255, 255, 255, 0.1)";
              textContainer.style.boxShadow =
                "0 0 0 4px rgba(255, 255, 255, 0.1)";
            }
          });

          textContainer.addEventListener(
            "touchstart",
            (e) => {
              // Don't drag if clicking on toolbar or buttons (including delete button in toolbar)
              if (
                e.target.closest(".text-formatting-toolbar") ||
                e.target.closest("button") ||
                e.target.tagName === "BUTTON"
              ) {
                return;
              }

              // If toolbar is visible, clicking on text should focus it, not drag
              if (toolbar.style.display === "flex") {
                if (
                  e.target === textElement ||
                  textElement.contains(e.target)
                ) {
                  textElement.focus();
                  return;
                }
              }

              // Prevent page scroll immediately to allow drag
              e.stopPropagation();

              // Record drag start
              dragStartTime = Date.now();
              const touch = e.touches[0];
              dragStartX = touch.clientX;
              dragStartY = touch.clientY;
              isDragging = false; // Will be set to true on move if movement detected

              // Log click/touch on text
              const containerRect = textContainer.getBoundingClientRect();
              console.log("ðŸ–ï¸ [DRAG] TOUCH STARTED on text:", {
                touchX: touch.clientX,
                touchY: touch.clientY,
                containerPosition: {
                  left: textContainer.style.left,
                  top: textContainer.style.top,
                  rectLeft: containerRect.left,
                  rectTop: containerRect.top,
                },
                isDragging: false,
              });
            },
            { passive: false }
          );

          textContainer.addEventListener(
            "touchmove",
            (e) => {
              // Prevent page scroll immediately - critical for instant drag
              e.preventDefault();
              e.stopPropagation();

              // Don't drag if touching toolbar or buttons
              if (
                e.target.closest(".text-formatting-toolbar") ||
                e.target.closest("button") ||
                e.target.tagName === "BUTTON"
              ) {
                return;
              }

              // If toolbar is visible, don't drag
              if (toolbar.style.display === "flex") {
                return;
              }

              const touch = e.touches[0];
              const deltaX = Math.abs(touch.clientX - dragStartX);
              const deltaY = Math.abs(touch.clientY - dragStartY);

              // Log finger/mouse movement
              if (!isDragging) {
                console.log("ðŸ–ï¸ [DRAG] FINGER MOVING (not dragging yet):", {
                  touchX: touch.clientX,
                  touchY: touch.clientY,
                  deltaX: deltaX,
                  deltaY: deltaY,
                  dragStartX: dragStartX,
                  dragStartY: dragStartY,
                  threshold: 2,
                  willStartDrag: deltaX > 2 || deltaY > 2,
                });
              }

              // Start dragging immediately on any movement
              if (!isDragging && (deltaX > 2 || deltaY > 2)) {
                isDragging = true;
                const rect = textContainer.getBoundingClientRect();
                const pageRect = page.getBoundingClientRect();
                startX = touch.clientX - rect.left;
                startY = touch.clientY - rect.top;
                cachedPageRect = pageRect;
                textContainer.style.cursor = "move";
                textContainer.style.transition = "none"; // Disable transition for instant drag

                // Log when drag actually starts
                console.log("ðŸ–ï¸ [DRAG] DRAG STARTED - Text is now moving:", {
                  touchX: touch.clientX,
                  touchY: touch.clientY,
                  startX: startX,
                  startY: startY,
                  initialPosition: {
                    left: textContainer.style.left,
                    top: textContainer.style.top,
                    rectLeft: rect.left,
                    rectTop: rect.top,
                  },
                  pageRect: {
                    left: pageRect.left,
                    top: pageRect.top,
                  },
                });
              }

              if (!isDragging) {
                return;
              }

              // Update position INSTANTLY - use cached pageRect, no recalculation
              if (!cachedPageRect) {
                cachedPageRect = page.getBoundingClientRect();
              }
              const newX = touch.clientX - cachedPageRect.left - startX;
              const newY = touch.clientY - cachedPageRect.top - startY;

              // Direct synchronous style update - instant like desktop, NO DELAY
              textContainer.style.left = newX + "px";
              textContainer.style.top = newY + "px";

              // Log position updates (throttled to avoid spam)
              if (
                !textContainer._lastLogTime ||
                Date.now() - textContainer._lastLogTime > 100
              ) {
                console.log("ðŸ–ï¸ [DRAG] POSITION UPDATED:", {
                  newX: newX,
                  newY: newY,
                  touchX: touch.clientX,
                  touchY: touch.clientY,
                  styleLeft: textContainer.style.left,
                  styleTop: textContainer.style.top,
                });
                textContainer._lastLogTime = Date.now();
              }
            },
            { passive: false }
          );

          textContainer.addEventListener("touchend", (e) => {
            // Don't interfere with toolbar buttons
            if (
              e.target.closest(".text-formatting-toolbar") ||
              e.target.closest("button")
            ) {
              return;
            }

            // If it was a quick tap (not a drag) and toolbar is hidden, show it
            if (!isDragging && toolbar.style.display === "none") {
              const touchDuration = Date.now() - dragStartTime;
              if (touchDuration < 300) {
                // Quick tap - show toolbar
                toolbar.style.display = "flex";
                textElement.contentEditable = true;
                textElement.focus();
                textContainer.style.border =
                  "2px solid rgba(255, 255, 255, 0.4)";
                textContainer.style.backgroundColor =
                  "rgba(255, 255, 255, 0.1)";
                textContainer.style.boxShadow =
                  "0 0 0 4px rgba(255, 255, 255, 0.1)";
                return;
              }
            }

            isDragging = false;
            cachedPageRect = null;
            textContainer.style.cursor = "default";
          });

          // Also support mouse for desktop testing
          let mouseDragStartTime = 0;
          let mouseDragStartX = 0;
          let mouseDragStartY = 0;

          textContainer.addEventListener("mousedown", (e) => {
            // Don't drag if clicking on toolbar or buttons
            if (
              e.target.closest(".text-formatting-toolbar") ||
              e.target.closest("button") ||
              e.target.tagName === "BUTTON"
            ) {
              return;
            }

            // If toolbar is visible, clicking on text should focus it, not drag
            if (toolbar.style.display === "flex") {
              if (e.target === textElement || textElement.contains(e.target)) {
                textElement.focus();
                return;
              }
            }

            mouseDragStartTime = Date.now();
            mouseDragStartX = e.clientX;
            mouseDragStartY = e.clientY;
            isDragging = false;

            // Log click on text
            const containerRect = textContainer.getBoundingClientRect();
            console.log("ðŸ–±ï¸ [DRAG] MOUSE CLICKED on text:", {
              mouseX: e.clientX,
              mouseY: e.clientY,
              containerPosition: {
                left: textContainer.style.left,
                top: textContainer.style.top,
                rectLeft: containerRect.left,
                rectTop: containerRect.top,
              },
              isDragging: false,
            });
          });

          textContainer.addEventListener("mousemove", (e) => {
            // Don't drag if touching toolbar or buttons
            if (
              e.target.closest(".text-formatting-toolbar") ||
              e.target.closest("button") ||
              e.target.tagName === "BUTTON"
            ) {
              return;
            }

            // If toolbar is visible, don't drag
            if (toolbar.style.display === "flex") {
              return;
            }

            const deltaX = Math.abs(e.clientX - mouseDragStartX);
            const deltaY = Math.abs(e.clientY - mouseDragStartY);

            // Log mouse movement
            if (!isDragging) {
              console.log("ðŸ–±ï¸ [DRAG] MOUSE MOVING (not dragging yet):", {
                mouseX: e.clientX,
                mouseY: e.clientY,
                deltaX: deltaX,
                deltaY: deltaY,
                mouseDragStartX: mouseDragStartX,
                mouseDragStartY: mouseDragStartY,
                threshold: 5,
                willStartDrag: deltaX > 5 || deltaY > 5,
              });
            }

            // Start dragging if moved more than 5px
            if (!isDragging && (deltaX > 5 || deltaY > 5)) {
              isDragging = true;
              e.preventDefault();
              const rect = textContainer.getBoundingClientRect();
              const pageRect = page.getBoundingClientRect();
              startX = e.clientX - rect.left;
              startY = e.clientY - rect.top;
              cachedPageRect = pageRect;
              textContainer.style.cursor = "move";
              textContainer.style.transition = "none"; // Disable transition for instant drag

              // Log when drag actually starts
              console.log("ðŸ–±ï¸ [DRAG] DRAG STARTED - Text is now moving:", {
                mouseX: e.clientX,
                mouseY: e.clientY,
                startX: startX,
                startY: startY,
                initialPosition: {
                  left: textContainer.style.left,
                  top: textContainer.style.top,
                  rectLeft: rect.left,
                  rectTop: rect.top,
                },
                pageRect: {
                  left: pageRect.left,
                  top: pageRect.top,
                },
              });
            }

            if (!isDragging) {
              return;
            }

            e.preventDefault();

            // Update position instantly - use cached pageRect, no recalculation
            if (!cachedPageRect) {
              cachedPageRect = page.getBoundingClientRect();
            }
            const newX = e.clientX - cachedPageRect.left - startX;
            const newY = e.clientY - cachedPageRect.top - startY;

            // Direct synchronous style update - instant like desktop, NO DELAY
            textContainer.style.left = newX + "px";
            textContainer.style.top = newY + "px";

            // Log position updates (throttled to avoid spam)
            if (
              !textContainer._lastMouseLogTime ||
              Date.now() - textContainer._lastMouseLogTime > 100
            ) {
              console.log("ðŸ–±ï¸ [DRAG] POSITION UPDATED:", {
                newX: newX,
                newY: newY,
                mouseX: e.clientX,
                mouseY: e.clientY,
                styleLeft: textContainer.style.left,
                styleTop: textContainer.style.top,
              });
              textContainer._lastMouseLogTime = Date.now();
            }
          });

          textContainer.addEventListener("mouseup", (e) => {
            if (
              e.target.closest(".text-formatting-toolbar") ||
              e.target.closest("button")
            ) {
              return;
            }

            // If it was a quick click (not a drag) and toolbar is hidden, show it
            if (!isDragging && toolbar.style.display === "none") {
              const clickDuration = Date.now() - mouseDragStartTime;
              if (clickDuration < 300) {
                // Quick click - show toolbar
                toolbar.style.display = "flex";
                textElement.contentEditable = true;
                textElement.focus();
                textContainer.style.border =
                  "2px solid rgba(255, 255, 255, 0.4)";
                textContainer.style.backgroundColor =
                  "rgba(255, 255, 255, 0.1)";
                textContainer.style.boxShadow =
                  "0 0 0 4px rgba(255, 255, 255, 0.1)";
                isDragging = false;
                return;
              }
            }

            isDragging = false;
            cachedPageRect = null;
            textContainer.style.cursor = "default";
          });

          // Show toolbar and focus text
          setTimeout(() => {
            console.log(
              "ðŸ“ [Mobile] Showing toolbar and focusing text element"
            );
            // Show toolbar immediately
            toolbar.style.display = "flex";
            textContainer.style.border = "2px solid rgba(255, 255, 255, 0.4)";
            textContainer.style.backgroundColor = "rgba(255, 255, 255, 0.1)";
            textContainer.style.boxShadow =
              "0 0 0 4px rgba(255, 255, 255, 0.1)";
            // Focus text element
            textElement.focus();
            console.log(
              "ðŸ“ [Mobile] Text element focused, activeElement:",
              document.activeElement
            );
            const range = document.createRange();
            range.selectNodeContents(textElement);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            console.log("ðŸ“ [Mobile] Text selected");
          }, 10);

          // Switch back to edit-text mode after creating text
          setTimeout(() => {
            window.parent.postMessage(
              {
                type: "EDIT_MODE_SET",
                mode: "edit-text",
              },
              "*"
            );
            console.log(
              "ðŸ“ [Mobile] Switched back to edit-text mode after creating text"
            );
          }, 100);

          console.log("ðŸ“ [Mobile] Text element created at:", x, y);
        }

        // Insert signature function
        function insertSignature(signatureData, pageNumber) {
          const page = document.querySelector(
            `.pdf-page:nth-child(${pageNumber})`
          );
          if (!page) {
            console.error("âŒ [Mobile] Page not found for signature insertion");
            return;
          }

          // Create signature container
          const signatureContainer = document.createElement("div");
          signatureContainer.className = "signature-container";
          signatureContainer.style.position = "absolute";
          signatureContainer.style.left = "50%";
          signatureContainer.style.top = "50%";
          signatureContainer.style.transform = "translate(-50%, -50%)";
          signatureContainer.style.width = "200px";
          signatureContainer.style.height = "100px";
          signatureContainer.style.zIndex = "100";
          signatureContainer.style.cursor = "move";

          // Create signature image
          const signatureImg = document.createElement("img");
          signatureImg.src = signatureData;
          signatureImg.style.width = "100%";
          signatureImg.style.height = "100%";
          signatureImg.style.objectFit = "contain";
          signatureImg.style.pointerEvents = "none";

          signatureContainer.appendChild(signatureImg);
          page.appendChild(signatureContainer);

          // Add resize handles
          const resizeHandle = document.createElement("div");
          resizeHandle.className = "resize-handle";
          resizeHandle.style.position = "absolute";
          resizeHandle.style.width = "20px";
          resizeHandle.style.height = "20px";
          resizeHandle.style.bottom = "0";
          resizeHandle.style.right = "0";
          resizeHandle.style.backgroundColor = "#3b82f6";
          resizeHandle.style.border = "2px solid white";
          resizeHandle.style.borderRadius = "50%";
          resizeHandle.style.cursor = "nwse-resize";
          resizeHandle.style.zIndex = "1001";
          signatureContainer.appendChild(resizeHandle);

          // Create delete button for signature
          const deleteBtn = document.createElement("button");
          deleteBtn.className = "element-delete-btn";
          deleteBtn.innerHTML = "Ã—";
          deleteBtn.title = "Delete signature";
          deleteBtn.style.lineHeight = "1";
          console.log("ðŸ—‘ï¸ [Mobile] Created delete button for signature");

          // Delete button event handler
          deleteBtn.addEventListener("click", async (e) => {
            console.log("ðŸ—‘ï¸ [Mobile] Delete button clicked for signature");
            e.preventDefault();
            e.stopPropagation();
            const confirmed = await showConfirmation(
              "Are you sure you want to delete this signature?"
            );
            if (confirmed) {
              signatureContainer.remove();
              console.log("ðŸ—‘ï¸ [Mobile] Signature deleted");
            }
          });

          // Prevent drag/resize when clicking delete button
          deleteBtn.addEventListener("touchstart", (e) => {
            e.stopPropagation();
          });

          deleteBtn.addEventListener("mousedown", (e) => {
            e.stopPropagation();
          });

          signatureContainer.appendChild(deleteBtn);

          // Make draggable
          let isDragging = false;
          let isResizing = false;
          let startX, startY, initialX, initialY, initialWidth, initialHeight;

          signatureContainer.addEventListener("touchstart", (e) => {
            // Don't drag/resize if clicking on delete button
            if (
              e.target.classList.contains("element-delete-btn") ||
              e.target.closest(".element-delete-btn")
            ) {
              return;
            }

            if (e.target === resizeHandle) {
              e.stopPropagation();
              isResizing = true;
              const touch = e.touches[0];
              const rect = signatureContainer.getBoundingClientRect();
              startX = touch.clientX;
              startY = touch.clientY;
              initialWidth = rect.width;
              initialHeight = rect.height;
              initialX = rect.left;
              initialY = rect.top;
            } else {
              e.preventDefault();
              isDragging = true;
              const touch = e.touches[0];
              const rect = signatureContainer.getBoundingClientRect();
              startX = touch.clientX - rect.left;
              startY = touch.clientY - rect.top;
            }
          });

          signatureContainer.addEventListener("touchmove", (e) => {
            // Don't drag/resize if touching delete button
            if (
              e.target.classList.contains("element-delete-btn") ||
              e.target.closest(".element-delete-btn")
            ) {
              return;
            }

            e.preventDefault();
            if (isResizing) {
              const touch = e.touches[0];
              const deltaX = touch.clientX - startX;
              const deltaY = touch.clientY - startY;
              const newWidth = Math.max(50, initialWidth + deltaX);
              const newHeight = Math.max(50, initialHeight + deltaY);
              signatureContainer.style.width = newWidth + "px";
              signatureContainer.style.height = newHeight + "px";
            } else if (isDragging) {
              const touch = e.touches[0];
              const pageRect = page.getBoundingClientRect();
              const newX = touch.clientX - pageRect.left - startX;
              const newY = touch.clientY - pageRect.top - startY;
              signatureContainer.style.left = newX + "px";
              signatureContainer.style.top = newY + "px";
              signatureContainer.style.transform = "none";
            }
          });

          // Show delete button when signature is clicked or touched
          let signatureTapStartTime = 0;
          let signatureTapStartX = 0;
          let signatureTapStartY = 0;

          const handleSignatureSelect = (e) => {
            // Don't show if clicking on delete button or resize handle
            if (
              e.target.classList.contains("element-delete-btn") ||
              e.target.closest(".element-delete-btn") ||
              e.target === resizeHandle
            ) {
              return;
            }

            if (e.type === "touchstart") {
              signatureTapStartTime = Date.now();
              const touch = e.touches[0];
              signatureTapStartX = touch.clientX;
              signatureTapStartY = touch.clientY;
            }

            // Remove selected from all other signatures
            document
              .querySelectorAll(".signature-container.selected")
              .forEach((container) => {
                if (container !== signatureContainer) {
                  container.classList.remove("selected");
                }
              });
            // Add selected class to show delete button
            signatureContainer.classList.add("selected");
          };

          signatureContainer.addEventListener("click", handleSignatureSelect);
          signatureContainer.addEventListener(
            "touchstart",
            handleSignatureSelect
          );

          signatureContainer.addEventListener("touchend", (e) => {
            // Handle drag end
            isDragging = false;
            isResizing = false;

            // Handle tap detection for selection
            if (signatureTapStartTime > 0 && !isDragging && !isResizing) {
              const touchDuration = Date.now() - signatureTapStartTime;
              const touch = e.changedTouches[0];
              const deltaX = Math.abs(touch.clientX - signatureTapStartX);
              const deltaY = Math.abs(touch.clientY - signatureTapStartY);

              // If it was a quick tap (not a drag), ensure selected state
              if (touchDuration < 300 && deltaX < 5 && deltaY < 5) {
                signatureContainer.classList.add("selected");
              }

              signatureTapStartTime = 0;
            }
          });

          // Hide delete button when clicking away from signature
          const handleSignatureDocumentClick = (e) => {
            if (!signatureContainer.contains(e.target)) {
              signatureContainer.classList.remove("selected");
            }
          };
          const handleSignatureDocumentTouch = (e) => {
            if (!signatureContainer.contains(e.target)) {
              signatureContainer.classList.remove("selected");
            }
          };
          document.addEventListener(
            "click",
            handleSignatureDocumentClick,
            true
          );
          document.addEventListener(
            "touchstart",
            handleSignatureDocumentTouch,
            true
          );

          // Clean up listener when element is removed
          const originalSignatureRemove = signatureContainer.remove;
          signatureContainer.remove = function () {
            document.removeEventListener(
              "click",
              handleSignatureDocumentClick,
              true
            );
            document.removeEventListener(
              "touchstart",
              handleSignatureDocumentTouch,
              true
            );
            originalSignatureRemove.call(this);
          };

          // Send confirmation
          window.parent.postMessage(
            {
              type: "SIGNATURE_INSERTED",
              page: pageNumber,
            },
            "*"
          );
        }

        // Insert image function
        function insertImage(imageData, fileName, pageNumber) {
          const page = document.querySelector(
            `.pdf-page:nth-child(${pageNumber})`
          );
          if (!page) {
            console.error("âŒ [Mobile] Page not found for image insertion");
            return;
          }

          // Create image container
          const imageContainer = document.createElement("div");
          imageContainer.className = "image-container";
          imageContainer.style.position = "absolute";
          imageContainer.style.left = "50%";
          imageContainer.style.top = "50%";
          imageContainer.style.transform = "translate(-50%, -50%)";
          imageContainer.style.width = "200px";
          imageContainer.style.height = "200px";
          imageContainer.style.minWidth = "50px";
          imageContainer.style.minHeight = "50px";
          imageContainer.style.zIndex = "100";
          imageContainer.style.cursor = "move";
          imageContainer.style.border = "2px dashed #3b82f6";
          imageContainer.style.borderRadius = "4px";

          // Create image element
          const img = document.createElement("img");
          img.src = imageData;
          img.style.width = "100%";
          img.style.height = "100%";
          img.style.objectFit = "contain";
          img.style.pointerEvents = "none";
          img.style.userSelect = "none";
          img.draggable = false;

          imageContainer.appendChild(img);
          page.appendChild(imageContainer);

          // Add resize handles
          const resizeHandle = document.createElement("div");
          resizeHandle.className = "resize-handle";
          resizeHandle.style.position = "absolute";
          resizeHandle.style.width = "20px";
          resizeHandle.style.height = "20px";
          resizeHandle.style.bottom = "0";
          resizeHandle.style.right = "0";
          resizeHandle.style.backgroundColor = "#3b82f6";
          resizeHandle.style.border = "2px solid white";
          resizeHandle.style.borderRadius = "50%";
          resizeHandle.style.cursor = "nwse-resize";
          resizeHandle.style.zIndex = "1001";
          imageContainer.appendChild(resizeHandle);

          // Create delete button for image
          const deleteBtn = document.createElement("button");
          deleteBtn.className = "element-delete-btn";
          deleteBtn.innerHTML = "Ã—";
          deleteBtn.title = "Delete image";
          deleteBtn.style.lineHeight = "1";
          console.log("ðŸ—‘ï¸ [Mobile] Created delete button for image");

          // Delete button event handler
          deleteBtn.addEventListener("click", async (e) => {
            console.log("ðŸ—‘ï¸ [Mobile] Delete button clicked for image");
            e.preventDefault();
            e.stopPropagation();
            const confirmed = await showConfirmation(
              "Are you sure you want to delete this image?"
            );
            if (confirmed) {
              imageContainer.remove();
              console.log("ðŸ—‘ï¸ [Mobile] Image deleted");
            }
          });

          // Prevent drag/resize when clicking delete button
          deleteBtn.addEventListener("touchstart", (e) => {
            e.stopPropagation();
          });

          deleteBtn.addEventListener("mousedown", (e) => {
            e.stopPropagation();
          });

          imageContainer.appendChild(deleteBtn);

          // Make draggable
          let isDragging = false;
          let isResizing = false;
          let startX, startY, initialX, initialY, initialWidth, initialHeight;

          imageContainer.addEventListener("touchstart", (e) => {
            // Don't drag/resize if clicking on delete button
            if (
              e.target.classList.contains("element-delete-btn") ||
              e.target.closest(".element-delete-btn")
            ) {
              return;
            }

            if (e.target === resizeHandle) {
              e.stopPropagation();
              isResizing = true;
              const touch = e.touches[0];
              const rect = imageContainer.getBoundingClientRect();
              startX = touch.clientX;
              startY = touch.clientY;
              initialWidth = rect.width;
              initialHeight = rect.height;
              initialX = rect.left;
              initialY = rect.top;
            } else {
              e.preventDefault();
              isDragging = true;
              const touch = e.touches[0];
              const rect = imageContainer.getBoundingClientRect();
              startX = touch.clientX - rect.left;
              startY = touch.clientY - rect.top;
            }
          });

          imageContainer.addEventListener("touchmove", (e) => {
            // Don't drag/resize if touching delete button
            if (
              e.target.classList.contains("element-delete-btn") ||
              e.target.closest(".element-delete-btn")
            ) {
              return;
            }

            e.preventDefault();
            if (isResizing) {
              const touch = e.touches[0];
              const deltaX = touch.clientX - startX;
              const deltaY = touch.clientY - startY;
              const newWidth = Math.max(50, initialWidth + deltaX);
              const newHeight = Math.max(50, initialHeight + deltaY);
              imageContainer.style.width = newWidth + "px";
              imageContainer.style.height = newHeight + "px";
            } else if (isDragging) {
              const touch = e.touches[0];
              const pageRect = page.getBoundingClientRect();
              const newX = touch.clientX - pageRect.left - startX;
              const newY = touch.clientY - pageRect.top - startY;
              imageContainer.style.left = newX + "px";
              imageContainer.style.top = newY + "px";
              imageContainer.style.transform = "none";
            }
          });

          // Show delete button when image is clicked or touched
          let imageTapStartTime = 0;
          let imageTapStartX = 0;
          let imageTapStartY = 0;

          const handleImageSelect = (e) => {
            // Don't show if clicking on delete button or resize handle
            if (
              e.target.classList.contains("element-delete-btn") ||
              e.target.closest(".element-delete-btn") ||
              e.target === resizeHandle
            ) {
              return;
            }

            if (e.type === "touchstart") {
              imageTapStartTime = Date.now();
              const touch = e.touches[0];
              imageTapStartX = touch.clientX;
              imageTapStartY = touch.clientY;
            }

            // Remove selected from all other images
            document
              .querySelectorAll(".image-container.selected")
              .forEach((container) => {
                if (container !== imageContainer) {
                  container.classList.remove("selected");
                }
              });
            // Add selected class to show delete button
            imageContainer.classList.add("selected");
          };

          imageContainer.addEventListener("click", handleImageSelect);
          imageContainer.addEventListener("touchstart", handleImageSelect);

          imageContainer.addEventListener("touchend", (e) => {
            // Handle drag end
            isDragging = false;
            isResizing = false;

            // Handle tap detection for selection
            if (imageTapStartTime > 0 && !isDragging && !isResizing) {
              const touchDuration = Date.now() - imageTapStartTime;
              const touch = e.changedTouches[0];
              const deltaX = Math.abs(touch.clientX - imageTapStartX);
              const deltaY = Math.abs(touch.clientY - imageTapStartY);

              // If it was a quick tap (not a drag), ensure selected state
              if (touchDuration < 300 && deltaX < 5 && deltaY < 5) {
                imageContainer.classList.add("selected");
              }

              imageTapStartTime = 0;
            }
          });

          // Hide delete button when clicking away from image
          const handleImageDocumentClick = (e) => {
            if (!imageContainer.contains(e.target)) {
              imageContainer.classList.remove("selected");
            }
          };
          const handleImageDocumentTouch = (e) => {
            if (!imageContainer.contains(e.target)) {
              imageContainer.classList.remove("selected");
            }
          };
          document.addEventListener("click", handleImageDocumentClick, true);
          document.addEventListener(
            "touchstart",
            handleImageDocumentTouch,
            true
          );

          // Clean up listener when element is removed
          const originalImageRemove = imageContainer.remove;
          imageContainer.remove = function () {
            document.removeEventListener(
              "click",
              handleImageDocumentClick,
              true
            );
            document.removeEventListener(
              "touchstart",
              handleImageDocumentTouch,
              true
            );
            originalImageRemove.call(this);
          };

          // Send confirmation
          window.parent.postMessage(
            {
              type: "IMAGE_INSERTED",
              page: pageNumber,
            },
            "*"
          );
        }

        // PDF generation function for mobile
        async function generatePDFForPreview() {
          try {
            // Check if libraries are loaded
            if (
              typeof html2canvas === "undefined" ||
              typeof window.jspdf === "undefined"
            ) {
              throw new Error("PDF generation libraries not loaded");
            }

            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
              orientation: "portrait",
              unit: "px",
              format: [595, 842], // A4 size
            });

            // Get all visible pages
            const pages = document.querySelectorAll(".pdf-page:not(.hidden)");

            for (let i = 0; i < pages.length; i++) {
              const page = pages[i];

              // Capture page as canvas
              const canvas = await html2canvas(page, {
                scale: 2,
                useCORS: true,
                logging: false,
              });

              const imgData = canvas.toDataURL("image/jpeg", 0.95);
              const imgWidth = 595;
              const imgHeight = (canvas.height * imgWidth) / canvas.width;

              // Add new page if not the first
              if (i > 0) {
                pdf.addPage();
              }

              // Add image to PDF
              pdf.addImage(imgData, "JPEG", 0, 0, imgWidth, imgHeight);
            }

            // Generate blob URL
            const pdfBlob = pdf.output("blob");
            const url = URL.createObjectURL(pdfBlob);

            // Send to parent
            window.parent.postMessage(
              {
                type: "PDF_GENERATED_FOR_PREVIEW",
                pdfUrl: url,
              },
              "*"
            );

            console.log("âœ… [Mobile] PDF generated successfully");
          } catch (error) {
            console.error("âŒ [Mobile] Error generating PDF:", error);
            window.parent.postMessage(
              {
                type: "PDF_GENERATION_ERROR",
                error: error.message,
              },
              "*"
            );
          }
        }
      });
    </script>
  </body>
</html>
